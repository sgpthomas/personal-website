<h2>Futil</h2>
<p>
    <a href="https://github.com/cucapra/futil">Futil</a> is a wacky <a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representation</a> for compiling <a href="https://github.com/cucapra/dahlia/">Dahlia</a> to <a href="https://en.wikipedia.org/wiki/Register-transfer_level">RTL</a> so that it can be run on an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
</p>
<p>
    Futil consists of a language for describing "structure" and a language for describing "control".
    The structure language is a simple combinatorial logic that lets you describe a static computation graph.
    A computation graph consists of nodes that represent sub-computations and edges that describe dataflow between
    edges.
</p>
<p>
    The control language describes how to dynamically choose the set of active computation nodes at a given time.
    When a computation node is active, it is allowed to execute. Otherwise, it ignores it's inputs and produces no value.
</p>
<p>
    Together these two languages give you a way to express programs as some combination of control and structure.
    The key observation is that the same program can be expressed using a varying degree of control and structure.
    Traditional programs CPU programs are entirely control and hardware implementations are entirely structure.
    This representation makes the problem of compiling traditional CPU programs into hardware the problem of turning control
    into structure. We think that this is potentially a powerful way of looking at the problem because
    (1) it allows the compilation process to be much more modular than existing methods and
    (2) it separates optimization concerns from compilation concerns which makes it easier to reason about the correctness
    of particular optimization passes.
</p>
<p>
    The last point may not actually be a good thing, we have yet to find out. It's possible that you may only
    perform good hardware optimizations by preserving as much information about the original program as possible,
    information which would be destroyed by optimizing orthogonally to compiling.
</p>

TODO: pics!

<h2>Data Scientist in a Box</h2>
<p>
    <a href="https://github.com/sgpthomas/sklearn-pmlb-benchmarks">PMLB Benchmark extension</a>
</p>
<p>
    <a href="https://github.com/sgpthomas/aws-automation">Aws Spot Fleet Automation Tool</a>
</p>
<p>
    <a href="https://github.com/sgpthomas/isi-analysis">PMLB analysis for ISI</a>
</p>
<p>
    <a href="https://github.com/sgpthomas/isi-metafeature-exploration">Metafeature exploration for ISI</a>
</p>

<h2>Distributed Systems Experimental Framework</h2>

<h2>Shrimp: Verifying IRs with Rosette</h2>

<h2>Polka</h2>
<a href="https://github.com/sgpthomas/polka">Polka</a> is a simple and extensible framework for keeping a single set of dot files
across multiple machines. TODO: write more.

<h2>LED Light Strip</h2>
<p>
    <a href="https://github.com/sgpthomas/light-tunnel-rkt">Light tunnel racket</a>
</p>
<p>
    <a href="https://github.com/sgpthomas/moodlight">Moodlight interface</a>
</p>

<h2>Elementary OS Apps</h2>

<h2>Work in progress</h2>
<p>
    <a href="https://github.com/sgpthomas/sexpy">Rust S-Exp Parser</a>
</p>
